Here's the parsing result:
(program (topLevelItem (attributes (innerAttribute # ! [ (attribute allow ( (attrArgs (attrArg dead_code) , (attrArg mutable_transmutes) , (attrArg non_camel_case_types) , (attrArg non_snake_case) , (attrArg non_upper_case_globals) , (attrArg unused_assignments) , (attrArg unused_mut)) )) ]) (innerAttribute # ! [ (attribute feature ( (attrArgs (attrArg extern_types)) )) ]))) (topLevelItem (externBlock extern "C" { (externItem (visibility pub) type _IO_wide_data ;) (externItem (visibility pub) type _IO_codecvt ;) (externItem (visibility pub) type _IO_marker ;) (externItem static mut stderr : (type (pointerType * mut (type (basicType (typePath FILE))))) ;) (externItem fn fprintf ( (externParams (externParam _ : (type (pointerType * mut (type (basicType (typePath FILE)))))) , (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn printf ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn malloc ( (externParams (externParam _ : (type (basicType (typePath libc :: c_ulong))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ;) (externItem fn strlen ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char))))))) ) -> (type (basicType (typePath libc :: c_ulong))) ;) })) (topLevelItem (typeAlias (visibility pub) type size_t = (type (basicType (typePath libc :: c_ulong))) ;)) (topLevelItem (typeAlias (visibility pub) type __off_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (typeAlias (visibility pub) type __off64_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct _IO_FILE { (structField (visibility pub) _flags : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _IO_read_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_backup_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _markers : (type (pointerType * mut (type (basicType (typePath _IO_marker))))) ,) (structField (visibility pub) _chain : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _fileno : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _flags2 : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _old_offset : (type (basicType (typePath __off_t))) ,) (structField (visibility pub) _cur_column : (type (basicType (typePath libc :: c_ushort))) ,) (structField (visibility pub) _vtable_offset : (type (basicType (typePath libc :: c_schar))) ,) (structField (visibility pub) _shortbuf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 1 ])) ,) (structField (visibility pub) _lock : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) _offset : (type (basicType (typePath __off64_t))) ,) (structField (visibility pub) _codecvt : (type (pointerType * mut (type (basicType (typePath _IO_codecvt))))) ,) (structField (visibility pub) _wide_data : (type (pointerType * mut (type (basicType (typePath _IO_wide_data))))) ,) (structField (visibility pub) _freeres_list : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _freeres_buf : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) __pad5 : (type (basicType (typePath size_t))) ,) (structField (visibility pub) _mode : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _unused2 : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 20 ])) ,) })) (topLevelItem (typeAlias (visibility pub) type _IO_lock_t = (type (basicType ())) ;)) (topLevelItem (typeAlias (visibility pub) type FILE = (type (basicType (typePath _IO_FILE))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct C2RustUnnamed { (structField (visibility pub) nalt : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) natom : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (typeAlias (visibility pub) type C2RustUnnamed_0 = (type (basicType (typePath libc :: c_uint))) ;)) (topLevelItem (constDef (visibility pub) const Split : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 257)))) ;)) (topLevelItem (constDef (visibility pub) const Match : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 256)))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct State { (structField (visibility pub) c : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out1 : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) lastlist : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct Frag { (structField (visibility pub) start : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (unionDef (visibility pub) union Ptrlist { (unionField (visibility pub) next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) (unionField (visibility pub) s : (type (pointerType * mut (type (basicType (typePath State))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct List { (structField (visibility pub) s : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))) ,) (structField (visibility pub) n : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn re2post ( (paramList (param mut re : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) (block { (statement (letStmt let (varDef (mutableDef mut nalt : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut natom : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (staticVarDecl static mut buf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) = (initializer (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression (literal 0)))) ; (expression (postfixExpression (primaryExpression (literal 8000)))) ])))))) ;)) (statement (letStmt let (varDef (mutableDef mut dst : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef (mutableDef mut paren : (type (basicType [ (type (basicType (typePath C2RustUnnamed))) ; 100 ])))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression C2RustUnnamed { (structLiteralField nalt : (expression (postfixExpression (primaryExpression (literal 0))))) , (structLiteralField natom : (expression (postfixExpression (primaryExpression (literal 0))))) }))) ; (expression (postfixExpression (primaryExpression (literal 100)))) ]))))) ;)) (statement (letStmt let (varDef (mutableDef mut p : (type (pointerType * mut (type (basicType (typePath C2RustUnnamed))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath C2RustUnnamed)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression strlen ( (argumentList (expression (postfixExpression (primaryExpression re)))) )))) >= (expression (postfixExpression (primaryExpression ( (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) >()) as (type (basicType (typePath libc :: c_ulong)))) )) . wrapping_div ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 2)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath libc :: c_ulong))))) )))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (whileStmt while (expression (expression * re) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement match (expression (expression * re) as (type (basicType (typePath libc :: c_int)))) { (matchArm (matchPattern 40) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 1))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) (statement (letStmt let (varDef (immutableDef fresh0)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression * fresh0) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) >= (expression (postfixExpression (primaryExpression paren) . as_mut_ptr () . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 100)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath isize))))) )))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * p) )) . nalt)) = (expression (postfixExpression (primaryExpression nalt))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * p) )) . natom)) = (expression (postfixExpression (primaryExpression natom))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement p ;) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) })) (matchArm (matchPattern 124) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef (immutableDef fresh1)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh1) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (expression (postfixExpression (primaryExpression nalt))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) })) (matchArm (matchPattern 41) => (block { (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) == (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ()))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef (immutableDef fresh2)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh2) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (whileStmt while (expression (expression (expression (postfixExpression (primaryExpression nalt))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (letStmt let (varDef (immutableDef fresh3)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh3) = (expression (expression (postfixExpression (primaryExpression (literal '|')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (expression (postfixExpression (primaryExpression nalt))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement p ;) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (postfixExpression (primaryExpression ( (expression * p) )) . nalt)) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (postfixExpression (primaryExpression ( (expression * p) )) . natom)) ;)) (statement (expression (postfixExpression (primaryExpression natom))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) })) (matchArm (matchPattern 42) | (matchPattern 43) | (matchPattern 63) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (letStmt let (varDef (immutableDef fresh4)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh4) = (expression * re) ;)) })) (matchArm (matchPattern _) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 1))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) (statement (letStmt let (varDef (immutableDef fresh5)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh5) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (letStmt let (varDef (immutableDef fresh6)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh6) = (expression * re) ;)) (statement (expression (postfixExpression (primaryExpression natom))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) })) }) (statement (assignStmt (expression (postfixExpression (primaryExpression re))) = (expression (postfixExpression (primaryExpression re) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement re ;) }))) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) != (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ()))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef (immutableDef fresh7)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh7) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (whileStmt while (expression (expression (expression (postfixExpression (primaryExpression nalt))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (letStmt let (varDef (immutableDef fresh8)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh8) = (expression (expression (postfixExpression (primaryExpression (literal '|')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (expression (postfixExpression (primaryExpression nalt))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) }))) (statement (assignStmt (expression * dst) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath libc :: c_char)))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut matchstate : (type (basicType (typePath State))) = (initializer (expression (expressionBlock { (statement (letStmt let (varDef (mutableDef mut init)) = (expression (postfixExpression (primaryExpression State { (structLiteralField c : (expression (expression (postfixExpression (primaryExpression Match))) as (type (basicType (typePath libc :: c_int))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (basicType (typePath State))))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out1 : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (basicType (typePath State))))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField lastlist : (expression (postfixExpression (primaryExpression (literal 0))))) , }))) ;)) (expression (postfixExpression (primaryExpression init))) }))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut nstate : (type (basicType (typePath libc :: c_int))) = (initializer (expression (postfixExpression (primaryExpression (literal 0))))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn state ( (paramList (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut out : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out1 : (type (pointerType * mut (type (basicType (typePath State)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (expression (postfixExpression (primaryExpression nstate))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nstate ;) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (expression (postfixExpression (primaryExpression malloc ( (argumentList (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType (typePath State))) >()) as (type (basicType (typePath libc :: c_ulong))))) )))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . lastlist)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . c)) = (expression (postfixExpression (primaryExpression c))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . out)) = (expression (postfixExpression (primaryExpression out))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . out1)) = (expression (postfixExpression (primaryExpression out1))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression s))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn frag ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) ) -> (type (basicType (typePath Frag))) (block { (statement (letStmt let (varDef (mutableDef mut n : (type (basicType (typePath Frag))))) = (expression (expressionBlock { (statement (letStmt let (varDef (mutableDef mut init)) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (postfixExpression (primaryExpression start)))) , (structLiteralField out : (expression (postfixExpression (primaryExpression out)))) }))) ;)) (expression (postfixExpression (primaryExpression init))) })) ;)) (returnStmt return (expression (postfixExpression (primaryExpression n))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn list1 ( (paramList (param mut outp : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef (mutableDef mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression l))) = (expression (expression (postfixExpression (primaryExpression outp))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * l) )) . next)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression l))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn patch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (letStmt let (varDef (mutableDef mut next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (whileStmt while (expression ! (expression (postfixExpression (primaryExpression l) . is_null ()))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression next))) = (expression (postfixExpression (primaryExpression ( (expression * l) )) . next)) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * l) )) . s)) = (expression (postfixExpression (primaryExpression s))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression l))) = (expression (postfixExpression (primaryExpression next))) ;)) }))) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn append ( (paramList (param mut l1_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut l2_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef (mutableDef mut oldl1 : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression oldl1))) = (expression (postfixExpression (primaryExpression l1_0))) ;)) (statement (whileStmt while (expression ! (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * l1_0) )) . next)) )) . is_null ()))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression l1_0))) = (expression (postfixExpression (primaryExpression ( (expression * l1_0) )) . next)) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * l1_0) )) . next)) = (expression (postfixExpression (primaryExpression l2_0))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression oldl1))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn post2nfa ( (paramList (param mut postfix : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut p : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef (mutableDef mut stack : (type (basicType [ (type (basicType (typePath Frag))) ; 1000 ])))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ; (expression (postfixExpression (primaryExpression (literal 1000)))) ]))))) ;)) (statement (letStmt let (varDef (mutableDef mut stackp : (type (pointerType * mut (type (basicType (typePath Frag))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Frag)))))) ;)) (statement (letStmt let (varDef (mutableDef mut e1 : (type (basicType (typePath Frag))))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef (mutableDef mut e2 : (type (basicType (typePath Frag))))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef (mutableDef mut e : (type (basicType (typePath Frag))))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (ifStmt if (expression (postfixExpression (primaryExpression postfix) . is_null ())) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stack) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression postfix))) ;)) (statement (whileStmt while (expression (expression * p) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement match (expression (expression * p) as (type (basicType (typePath libc :: c_int)))) { (matchArm (matchPattern 46) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e2))) = (expression * stackp) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e1))) = (expression * stackp) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression patch ( (argumentList (expression (postfixExpression (primaryExpression e1) . out)) , (expression (postfixExpression (primaryExpression e2) . start))) )))) ;)) (statement (letStmt let (varDef (immutableDef fresh10)) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh10) = (expression (postfixExpression (primaryExpression frag ( (argumentList (expression (postfixExpression (primaryExpression e1) . start)) , (expression (postfixExpression (primaryExpression e2) . out))) )))) ;)) })) (matchArm (matchPattern 124) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e2))) = (expression * stackp) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e1))) = (expression * stackp) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e1) . start)) , (expression (postfixExpression (primaryExpression e2) . start))) )))) ;)) (statement (letStmt let (varDef (immutableDef fresh11)) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh11) = (expression (postfixExpression (primaryExpression frag ( (argumentList (expression (postfixExpression (primaryExpression s))) , (expression (postfixExpression (primaryExpression append ( (argumentList (expression (postfixExpression (primaryExpression e1) . out)) , (expression (postfixExpression (primaryExpression e2) . out))) ))))) )))) ;)) })) (matchArm (matchPattern 63) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e))) = (expression * stackp) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e) . start)) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) )))) ;)) (statement (letStmt let (varDef (immutableDef fresh12)) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh12) = expression <missing ';'>)))) (matchArm (matchPattern frag)) <missing '}'>)))) ( s , append ( e . out , list1 ( & mut ( * s ) . out1 ) ) ) ; } 42 => { stackp = stackp . offset ( -1 ) ; e = * stackp ; s = state ( Split as libc :: c_int , e . start , 0 as * mut State ) ; patch ( e . out , s ) ; let fresh13 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh13 = frag ( s , list1 ( & mut ( * s ) . out1 ) ) ; } 43 => { stackp = stackp . offset ( -1 ) ; e = * stackp ; s = state ( Split as libc :: c_int , e . start , 0 as * mut State ) ; patch ( e . out , s ) ; let fresh14 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh14 = frag ( e . start , list1 ( & mut ( * s ) . out1 ) ) ; } _ => { s = state ( * p as libc :: c_int , 0 as * mut State , 0 as * mut State ) ; let fresh9 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh9 = frag ( s , list1 ( & mut ( * s ) . out ) ) ; } } p = p . offset ( 1 ) ; p ; } stackp = stackp . offset ( -1 ) ; e = * stackp ; if stackp != stack . as_mut_ptr () { return 0 as * mut State ; } patch ( e . out , & mut matchstate ) ; return e . start ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut l1 : (type (basicType (typePath List))) = (initializer (expression (postfixExpression (primaryExpression List { (structLiteralField s : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (pointerType * mut (type (basicType (typePath State))))))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) , (structLiteralField n : (expression (postfixExpression (primaryExpression (literal 0))))) , })))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut l2 : (type (basicType (typePath List))) = (initializer (expression (postfixExpression (primaryExpression List { (structLiteralField s : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (pointerType * mut (type (basicType (typePath State))))))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) , (structLiteralField n : (expression (postfixExpression (primaryExpression (literal 0))))) , })))) ;)) (topLevelItem (staticVarDecl static mut listid : (type (basicType (typePath libc :: c_int))) = (initializer (expression (postfixExpression (primaryExpression (literal 0))))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn startlist ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath List))))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * l) )) . n)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (expression (postfixExpression (primaryExpression listid))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement listid ;) (statement (exprStmt (expression (postfixExpression (primaryExpression addstate ( (argumentList (expression (postfixExpression (primaryExpression l))) , (expression (postfixExpression (primaryExpression start)))) )))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression l))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn ismatch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List))))))) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression i))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (whileStmt while (expression (expression (postfixExpression (primaryExpression i))) < (expression (postfixExpression (primaryExpression ( (expression * l) )) . n))) (block { (statement (ifStmt if (expression *) (block <missing '{'>)))))) ( ( * l ) . s ) . offset ( i as isize ) == & mut matchstate as * mut State { return 1 as libc :: c_int ; } i += 1 ; i ; } return 0 as libc :: c_int ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn addstate ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (ifStmt if (expression (postfixExpression (primaryExpression s) . is_null ())) (block | |))) ( * s ) . lastlist == listid { return ; } ( * s ) . lastlist = listid ; if ( * s ) . c == Split as libc :: c_int { addstate ( l , ( * s ) . out ) ; addstate ( l , ( * s ) . out1 ) ; return ; } let fresh15 = ( * l ) . n ; ( * l ) . n = ( * l ) . n + 1 ; let ref mut fresh16 = * ( ( * l ) . s ) . offset ( fresh15 as isize ) ; * fresh16 = s ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn step ( (paramList (param mut clist : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut nlist : (type (pointerType * mut (type (basicType (typePath List)))))) ,) ) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (expression (postfixExpression (primaryExpression listid))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement listid ;) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * nlist) )) . n)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression i))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (whileStmt while (expression (expression (postfixExpression (primaryExpression i))) < (expression (postfixExpression (primaryExpression ( (expression * clist) )) . n))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression *) <missing ';'>)) (statement (exprStmt (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * clist) )) . s)) )) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression i))) as (type (basicType (typePath isize))))) ))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression ( (expression * s) )) . c)) == (expression (postfixExpression (primaryExpression c)))) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression addstate ( (argumentList (expression (postfixExpression (primaryExpression nlist))) , (expression (postfixExpression (primaryExpression ( (expression * s) )) . out))) )))) ;)) }))) (statement (expression (postfixExpression (primaryExpression i))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement i ;) }))) }))) (topLevelItem (attributes (innerAttribute # [ (attribute export_name) = "match" ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn match_0 ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ,) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut c : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut clist : (type (pointerType * mut (type (basicType (typePath List))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (letStmt let (varDef (mutableDef mut nlist : (type (pointerType * mut (type (basicType (typePath List))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (letStmt let (varDef (mutableDef mut t : (type (pointerType * mut (type (basicType (typePath List))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression clist))) = expression <missing ';'>)) startlist ( start , & mut l1 ) ; nlist = & mut l2 ; while * s != 0 { c = * s as libc :: c_int & 0 xff as libc :: c_int ; step ( clist , c , nlist ) ; t = clist ; clist = nlist ; nlist = t ; s = s . offset ( 1 ) ; s ; } return ismatch ( clist ) ; }))) (topLevelItem (functionDef (unsafeModifier unsafe) fn main_0 ( (paramList (param mut argc : (type (basicType (typePath libc :: c_int)))) , (param mut argv : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))))) ,) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut post : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef (mutableDef mut start : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression argc))) < (expression (postfixExpression (primaryExpression (literal 3))))) as (type (basicType (typePath libc :: c_int)))) (block {))) fprintf ( stderr , b "usage: nfa regexp string...\n\0" as *))) (topLevelItem (constDef const u8 as *)) (topLevelItem (constDef const libc <missing ':'> (type (basicType :: c_char , ) ; return 1 as libc :: c_int ; } post)) = (expression re2post ( * argv . offset ( 1 as libc :: c_int as isize ) )) ;)))