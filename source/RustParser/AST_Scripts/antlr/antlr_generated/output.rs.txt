Here's the parsing result:
(program (topLevelItem (attributes (innerAttribute # ! [ (attribute allow ( (attrArgs (attrArg dead_code) , (attrArg mutable_transmutes) , (attrArg non_camel_case_types) , (attrArg non_snake_case) , (attrArg non_upper_case_globals) , (attrArg unused_assignments) , (attrArg unused_mut)) )) ]) (innerAttribute # ! [ (attribute feature ( (attrArgs (attrArg extern_types)) )) ]))) (topLevelItem (externBlock extern "C" { (externItem (visibility pub) type _IO_wide_data ;) (externItem (visibility pub) type _IO_codecvt ;) (externItem (visibility pub) type _IO_marker ;) (externItem static mut stderr : (type (pointerType * mut (type (basicType (typePath FILE))))) ;) (externItem fn fprintf ( (externParams (externParam _ : (type (pointerType * mut (type (basicType (typePath FILE)))))) , (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn printf ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn malloc ( (externParams (externParam _ : (type (basicType (typePath libc :: c_ulong))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ;) (externItem fn strlen ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char))))))) ) -> (type (basicType (typePath libc :: c_ulong))) ;) })) (topLevelItem (typeAlias (visibility pub) type size_t = (type (basicType (typePath libc :: c_ulong))) ;)) (topLevelItem (typeAlias (visibility pub) type __off_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (typeAlias (visibility pub) type __off64_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct _IO_FILE { (structField (visibility pub) _flags : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _IO_read_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_backup_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _markers : (type (pointerType * mut (type (basicType (typePath _IO_marker))))) ,) (structField (visibility pub) _chain : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _fileno : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _flags2 : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _old_offset : (type (basicType (typePath __off_t))) ,) (structField (visibility pub) _cur_column : (type (basicType (typePath libc :: c_ushort))) ,) (structField (visibility pub) _vtable_offset : (type (basicType (typePath libc :: c_schar))) ,) (structField (visibility pub) _shortbuf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 1 ])) ,) (structField (visibility pub) _lock : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) _offset : (type (basicType (typePath __off64_t))) ,) (structField (visibility pub) _codecvt : (type (pointerType * mut (type (basicType (typePath _IO_codecvt))))) ,) (structField (visibility pub) _wide_data : (type (pointerType * mut (type (basicType (typePath _IO_wide_data))))) ,) (structField (visibility pub) _freeres_list : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _freeres_buf : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) __pad5 : (type (basicType (typePath size_t))) ,) (structField (visibility pub) _mode : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _unused2 : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 20 ])) ,) })) (topLevelItem (typeAlias (visibility pub) type _IO_lock_t = (type (basicType ())) ;)) (topLevelItem (typeAlias (visibility pub) type FILE = (type (basicType (typePath _IO_FILE))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct C2RustUnnamed { (structField (visibility pub) nalt : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) natom : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (typeAlias (visibility pub) type C2RustUnnamed_0 = (type (basicType (typePath libc :: c_uint))) ;)) (topLevelItem (constDef (visibility pub) const Split : (type (basicType (typePath C2RustUnnamed_0))) = (expression (literal 257)) ;)) (topLevelItem (constDef (visibility pub) const Match : (type (basicType (typePath C2RustUnnamed_0))) = (expression (literal 256)) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct State { (structField (visibility pub) c : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out1 : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) lastlist : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct Frag { (structField (visibility pub) start : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (unionDef (visibility pub) union Ptrlist { (unionField (visibility pub) next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) (unionField (visibility pub) s : (type (pointerType * mut (type (basicType (typePath State))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct List { (structField (visibility pub) s : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))) ,) (structField (visibility pub) n : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn re2post ( (paramList (param mut re : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) (block { (statement (letStmt let (varDef (mutableDef mut nalt : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut natom : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (staticVarDecl static mut buf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) = (expression (literal (arrayLiteral [ (expression (literal 0)) ; (expression (literal 8000)) ]))) ;)) (statement (letStmt let (varDef (mutableDef mut dst : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (expression (literal 0)) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef (mutableDef mut paren : (type (basicType [ (type (basicType (typePath C2RustUnnamed))) ; 100 ])))) = (expression (literal (arrayLiteral [ (expression (primaryExpression C2RustUnnamed { (structLiteralField nalt : (expression (literal 0))) , (structLiteralField natom : (expression (literal 0))) })) ; (expression (literal 100)) ]))) ;)) (statement (letStmt let (varDef (mutableDef mut p : (type (pointerType * mut (type (basicType (typePath C2RustUnnamed))))))) = (expression (expression (literal 0)) as (type (pointerType * mut (type (basicType (typePath C2RustUnnamed)))))) ;)) (statement (assignStmt (expression (primaryExpression p)) = (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (primaryExpression dst)) = (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (primaryExpression nalt)) = (expression (expression (literal 0)) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (primaryExpression natom)) = (expression (expression (literal 0)) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (ifStmt if (expression (primaryExpression strlen ( (argumentList (expression (primaryExpression re))) ))) (block > =))) ( :: core :: mem :: size_of :: < [ libc :: c_char ; 8000 ] > () as libc :: c_ulong ) . wrapping_div ( 2 as libc :: c_int as libc :: c_ulong ) { return 0 as * mut libc :: c_char ; } while * re ! = 0 { match * re as libc :: c_int { 40 => { if natom > 1 as libc :: c_int { natom -= 1 ; natom ; let fresh0 = dst ; dst = dst . offset ( 1 ) ; * fresh0 = '.' as i32 as libc :: c_char ; } if p > = paren . as_mut_ptr () . offset ( 100 as libc :: c_int as isize ) { return 0 as * mut libc :: c_char ; } ( * p ) . nalt = nalt ; ( * p ) . natom = natom ; p = p . offset ( 1 ) ; p ; nalt = 0 as libc :: c_int ; natom = 0 as libc :: c_int ; } 124 => { if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh1 = dst ; dst = dst . offset ( 1 ) ; * fresh1 = '.' as i32 as libc :: c_char ; } nalt += 1 ; nalt ; } 41 => { if p == paren . as_mut_ptr () { return 0 as * mut libc :: c_char ; } if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh2 = dst ; dst = dst . offset ( 1 ) ; * fresh2 = '.' as i32 as libc :: c_char ; } while nalt > 0 as libc :: c_int { let fresh3 = dst ; dst = dst . offset ( 1 ) ; * fresh3 = '|' as i32 as libc :: c_char ; nalt -= 1 ; nalt ; } p = p . offset ( - 1 ) ; p ; nalt = ( * p ) . nalt ; natom = ( * p ) . natom ; natom += 1 ; natom ; } 42 | 43 | 63 => { if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } let fresh4 = dst ; dst = dst . offset ( 1 ) ; * fresh4 = * re ; } _ => { if natom > 1 as libc :: c_int { natom -= 1 ; natom ; let fresh5 = dst ; dst = dst . offset ( 1 ) ; * fresh5 = '.' as i32 as libc :: c_char ; } let fresh6 = dst ; dst = dst . offset ( 1 ) ; * fresh6 = * re ; natom += 1 ; natom ; } } re = re . offset ( 1 ) ; re ; } if p ! = paren . as_mut_ptr () { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh7 = dst ; dst = dst . offset ( 1 ) ; * fresh7 = '.' as i32 as libc :: c_char ; } while nalt > 0 as libc :: c_int { let fresh8 = dst ; dst = dst . offset ( 1 ) ; * fresh8 = '|' as i32 as libc :: c_char ; nalt -= 1 ; nalt ; } * dst = 0 as libc :: c_int as libc :: c_char ; return buf . as_mut_ptr () ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut matchstate : State = { let mut init = State { c : Match as libc :: c_int , out : 0 as *) (topLevelItem (constDef const State as * mut State , out1 : 0 as *)) (topLevelItem (constDef const State as * mut State , lastlist : 0 , } ; init } ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut nstate : libc :: c_int = 0 ;) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn state ( (paramList (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut out : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out1 : (type (pointerType * mut (type (basicType (typePath State)))))) , param) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (literal 0)) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (exprStmt (expression (expression (primaryExpression nstate)) += (expression (literal 1))) ;)) (statement (exprStmt (expression (primaryExpression nstate)) ;)) (statement (assignStmt (expression (primaryExpression s)) = expression <missing ';'>)) malloc ( :: core :: mem :: size_of :: < State > () as libc :: c_ulong ) as * mut State ; ( * s ) . lastlist = 0 as libc :: c_int ; ( * s ) . c = c ; ( * s ) . out = out ; ( * s ) . out1 = out1 ; return s ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn frag ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) ) -> (type (basicType (typePath Frag))) (block { (statement (letStmt let (varDef (mutableDef mut n : (type (basicType (typePath Frag))))) = (expression {) <missing ';'>)) (statement (letStmt let (varDef (mutableDef mut init)) = (expression (primaryExpression Frag { (structLiteralField start : (expression (primaryExpression start))) , (structLiteralField out : (expression (primaryExpression out))) })) ;)) (returnStmt (expression (primaryExpression init))) }))))