Here's the parsing result:
(program (topLevelItem (attributes (innerAttribute # ! [ (attribute allow ( (attrArgs (attrArg dead_code) , (attrArg mutable_transmutes) , (attrArg non_camel_case_types) , (attrArg non_snake_case) , (attrArg non_upper_case_globals) , (attrArg unused_assignments) , (attrArg unused_mut)) )) ]) (innerAttribute # ! [ (attribute feature ( (attrArgs (attrArg extern_types)) )) ]))) (topLevelItem (externBlock extern "C" { (externItem (visibility pub) type _IO_wide_data ;) (externItem (visibility pub) type _IO_codecvt ;) (externItem (visibility pub) type _IO_marker ;) (externItem static mut stderr : (type (pointerType * mut (type (basicType (typePath FILE))))) ;) (externItem fn fprintf ( (externParams (externParam _ : (type (pointerType * mut (type (basicType (typePath FILE)))))) , (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn printf ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn malloc ( (externParams (externParam _ : (type (basicType (typePath libc :: c_ulong))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ;) (externItem fn strlen ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char))))))) ) -> (type (basicType (typePath libc :: c_ulong))) ;) })) (topLevelItem (typeAlias (visibility pub) type size_t = (type (basicType (typePath libc :: c_ulong))) ;)) (topLevelItem (typeAlias (visibility pub) type __off_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (typeAlias (visibility pub) type __off64_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct _IO_FILE { (structField (visibility pub) _flags : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _IO_read_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_backup_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _markers : (type (pointerType * mut (type (basicType (typePath _IO_marker))))) ,) (structField (visibility pub) _chain : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _fileno : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _flags2 : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _old_offset : (type (basicType (typePath __off_t))) ,) (structField (visibility pub) _cur_column : (type (basicType (typePath libc :: c_ushort))) ,) (structField (visibility pub) _vtable_offset : (type (basicType (typePath libc :: c_schar))) ,) (structField (visibility pub) _shortbuf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 1 ])) ,) (structField (visibility pub) _lock : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) _offset : (type (basicType (typePath __off64_t))) ,) (structField (visibility pub) _codecvt : (type (pointerType * mut (type (basicType (typePath _IO_codecvt))))) ,) (structField (visibility pub) _wide_data : (type (pointerType * mut (type (basicType (typePath _IO_wide_data))))) ,) (structField (visibility pub) _freeres_list : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _freeres_buf : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) __pad5 : (type (basicType (typePath size_t))) ,) (structField (visibility pub) _mode : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _unused2 : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 20 ])) ,) })) (topLevelItem (typeAlias (visibility pub) type _IO_lock_t = (type (basicType ())) ;)) (topLevelItem (typeAlias (visibility pub) type FILE = (type (basicType (typePath _IO_FILE))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct C2RustUnnamed { (structField (visibility pub) nalt : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) natom : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (typeAlias (visibility pub) type C2RustUnnamed_0 = (type (basicType (typePath libc :: c_uint))) ;)) (topLevelItem (constDef (visibility pub) const Split : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 257)))) ;)) (topLevelItem (constDef (visibility pub) const Match : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 256)))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct State { (structField (visibility pub) c : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out1 : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) lastlist : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct Frag { (structField (visibility pub) start : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (unionDef (visibility pub) union Ptrlist { (unionField (visibility pub) next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) (unionField (visibility pub) s : (type (pointerType * mut (type (basicType (typePath State))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct List { (structField (visibility pub) s : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))) ,) (structField (visibility pub) n : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn re2post ( (paramList (param mut re : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) (block { (statement (letStmt let (varDef (mutableDef mut nalt : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef (mutableDef mut natom : (type (basicType (typePath libc :: c_int))))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (staticVarDecl static mut buf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression (literal 0)))) ; (expression (postfixExpression (primaryExpression (literal 8000)))) ]))))) ;)) (statement (letStmt let (varDef (mutableDef mut dst : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef (mutableDef mut paren : (type (basicType [ (type (basicType (typePath C2RustUnnamed))) ; 100 ])))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression C2RustUnnamed { (structLiteralField nalt : (expression (postfixExpression (primaryExpression (literal 0))))) , (structLiteralField natom : (expression (postfixExpression (primaryExpression (literal 0))))) }))) ; (expression (postfixExpression (primaryExpression (literal 100)))) ]))))) ;)) (statement (letStmt let (varDef (mutableDef mut p : (type (pointerType * mut (type (basicType (typePath C2RustUnnamed))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath C2RustUnnamed)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression strlen ( (argumentList (expression (postfixExpression (primaryExpression re)))) )))) >= (expression (postfixExpression (primaryExpression ( (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) >()) as (type (basicType (typePath libc :: c_ulong)))) )) . wrapping_div ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 2)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath libc :: c_ulong))))) )))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (whileStmt while (expression (expression * re) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement match (expression (expression * re) as (type (basicType (typePath libc :: c_int)))) { (matchArm (matchPattern 40) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 1))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) (statement (letStmt let (varDef (immutableDef fresh0)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression * fresh0) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) >= (expression (postfixExpression (primaryExpression paren) . as_mut_ptr () . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 100)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath isize))))) )))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * p) )) . nalt)) = (expression (postfixExpression (primaryExpression nalt))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * p) )) . natom)) = (expression (postfixExpression (primaryExpression natom))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement p ;) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) })) (matchArm (matchPattern 124) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) )))) (block { (statement break ;) }))) (statement (letStmt let (varDef (immutableDef fresh1)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh1) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (expression (postfixExpression (primaryExpression nalt))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) })) (matchArm (matchPattern 41) => (block { (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) == (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ()))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) )))) (block { (statement break ;) }))) (statement (letStmt let (varDef (immutableDef fresh2)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh2) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (whileStmt while (expression (expression (expression (postfixExpression (primaryExpression nalt))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (letStmt let (varDef (immutableDef fresh3)) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * fresh3) = (expression (expression (postfixExpression (primaryExpression (literal '|')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (expression (postfixExpression (primaryExpression nalt))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset)) <missing ';'>)))) <missing '}'>) ( -))) 1 ) ; p ; nalt = ( * p ) . nalt ; natom = ( * p ) . natom ; natom += 1 ; natom ; } 42 | 43 | 63 => { if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } let fresh4 = dst ; dst = dst . offset ( 1 ) ; * fresh4 = * re ; } _ => { if natom > 1 as libc :: c_int { natom -= 1 ; natom ; let fresh5 = dst ; dst = dst . offset ( 1 ) ; * fresh5 = '.' as i32 as libc :: c_char ; } let fresh6 = dst ; dst = dst . offset ( 1 ) ; * fresh6 = * re ; natom += 1 ; natom ; } } re = re . offset ( 1 ) ; re ; } if p != paren . as_mut_ptr () { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh7 = dst ; dst = dst . offset ( 1 ) ; * fresh7 = '.' as i32 as libc :: c_char ; } while nalt > 0 as libc :: c_int { let fresh8 = dst ; dst = dst . offset ( 1 ) ; * fresh8 = '|' as i32 as libc :: c_char ; nalt -= 1 ; nalt ; } * dst = 0 as libc :: c_int as libc :: c_char ; return buf . as_mut_ptr () ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut matchstate : State = { let mut init = State { c : Match as libc :: c_int , out : 0 as *) (topLevelItem (constDef const State as * mut State , out1 : 0 as *)) (topLevelItem (constDef const State as * mut State , lastlist : 0 , } ; init } ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut nstate : libc :: c_int = 0 ;) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn state ( (paramList (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut out : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out1 : (type (pointerType * mut (type (basicType (typePath State)))))) , param) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (expression (postfixExpression (primaryExpression nstate))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nstate ;) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (expression (postfixExpression (primaryExpression malloc ( (argumentList (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType (typePath State))) >()) as (type (basicType (typePath libc :: c_ulong))))) )))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . lastlist)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . c)) = (expression (postfixExpression (primaryExpression c))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . out)) = (expression (postfixExpression (primaryExpression out))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * s) )) . out1)) = (expression (postfixExpression (primaryExpression out1))) ;)) (returnStmt return (expression (postfixExpression (primaryExpression s))) ;) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn frag ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) ) -> (type (basicType (typePath Frag))) (block { (statement (letStmt let (varDef (mutableDef mut n : (type (basicType (typePath Frag))))) = (expression {) <missing ';'>)) (statement (letStmt let (varDef (mutableDef mut init)) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (postfixExpression (primaryExpression start)))) , (structLiteralField out : (expression (postfixExpression (primaryExpression out)))) }))) ;)) (returnStmt (expression (postfixExpression (primaryExpression init)))) }))))