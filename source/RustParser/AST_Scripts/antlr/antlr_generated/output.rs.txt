Here's the parsing result:
(program (topLevelItem (attributes (innerAttribute # ! [ (attribute allow ( (attrArgs (attrArg dead_code) , (attrArg mutable_transmutes) , (attrArg non_camel_case_types) , (attrArg non_snake_case) , (attrArg non_upper_case_globals) , (attrArg unused_assignments) , (attrArg unused_mut)) )) ]) (innerAttribute # ! [ (attribute feature ( (attrArgs (attrArg extern_types)) )) ]))) (topLevelItem (externBlock extern "C" { (externItem (visibility pub) type _IO_wide_data ;) (externItem (visibility pub) type _IO_codecvt ;) (externItem (visibility pub) type _IO_marker ;) (externItem static mut stderr : (type (pointerType * mut (type (basicType (typePath FILE))))) ;) (externItem fn fprintf ( (externParams (externParam _ : (type (pointerType * mut (type (basicType (typePath FILE)))))) , (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn printf ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn malloc ( (externParams (externParam _ : (type (basicType (typePath libc :: c_ulong))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ;) (externItem fn strlen ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char))))))) ) -> (type (basicType (typePath libc :: c_ulong))) ;) })) (topLevelItem (typeAlias (visibility pub) type size_t = (type (basicType (typePath libc :: c_ulong))) ;)) (topLevelItem (typeAlias (visibility pub) type __off_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (typeAlias (visibility pub) type __off64_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct _IO_FILE { (structField (visibility pub) _flags : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _IO_read_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_backup_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _markers : (type (pointerType * mut (type (basicType (typePath _IO_marker))))) ,) (structField (visibility pub) _chain : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _fileno : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _flags2 : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _old_offset : (type (basicType (typePath __off_t))) ,) (structField (visibility pub) _cur_column : (type (basicType (typePath libc :: c_ushort))) ,) (structField (visibility pub) _vtable_offset : (type (basicType (typePath libc :: c_schar))) ,) (structField (visibility pub) _shortbuf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 1 ])) ,) (structField (visibility pub) _lock : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) _offset : (type (basicType (typePath __off64_t))) ,) (structField (visibility pub) _codecvt : (type (pointerType * mut (type (basicType (typePath _IO_codecvt))))) ,) (structField (visibility pub) _wide_data : (type (pointerType * mut (type (basicType (typePath _IO_wide_data))))) ,) (structField (visibility pub) _freeres_list : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _freeres_buf : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) __pad5 : (type (basicType (typePath size_t))) ,) (structField (visibility pub) _mode : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _unused2 : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 20 ])) ,) })) (topLevelItem (typeAlias (visibility pub) type _IO_lock_t = (type (basicType ())) ;)) (topLevelItem (typeAlias (visibility pub) type FILE = (type (basicType (typePath _IO_FILE))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct C2RustUnnamed { (structField (visibility pub) nalt : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) natom : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (typeAlias (visibility pub) type C2RustUnnamed_0 = (type (basicType (typePath libc :: c_uint))) ;)) (topLevelItem (constDef (visibility pub) const Split : (type (basicType (typePath C2RustUnnamed_0))) = (expression (literal 257)) ;)) (topLevelItem (constDef (visibility pub) const Match : (type (basicType (typePath C2RustUnnamed_0))) = (expression (literal 256)) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct State { (structField (visibility pub) c : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out1 : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) lastlist : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct Frag { (structField (visibility pub) start : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (unionDef (visibility pub) union Ptrlist { (unionField (visibility pub) next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) (unionField (visibility pub) s : (type (pointerType * mut (type (basicType (typePath State))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct List { (structField (visibility pub) s : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))) ,) (structField (visibility pub) n : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn re2post ( (paramList (param mut re : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) (block { (statement (letStmt let (varDef (mutableDef mut nalt : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut natom : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) static mut buf : [ libc :: c_char ; 8000 ] = [ 0 ; 8000 ] ; let mut dst : * mut libc :: c_char = 0 as * mut libc :: c_char ; let mut paren : [ C2RustUnnamed ; 100 ] = [ C2RustUnnamed { nalt : 0 , natom : 0 } ; 100 ] ; let mut p : * mut C2RustUnnamed = 0 as * mut C2RustUnnamed ; p = paren . as_mut_ptr () ; dst = buf . as_mut_ptr () ; nalt = 0 as libc :: c_int ; natom = 0 as libc :: c_int ; if strlen ( re ) > = ( :: core :: mem :: size_of :: < [ libc :: c_char ; 8000 ] > () as libc :: c_ulong ) . wrapping_div ( 2 as libc :: c_int as libc :: c_ulong ) { return 0 as * mut libc :: c_char ; } while * re ! = 0 { match * re as libc :: c_int { 40 = > { if natom > 1 as libc :: c_int { natom -= 1 ; natom ; let fresh0 = dst ; dst = dst . offset ( 1 ) ; * fresh0 = . as i32 as libc :: c_char ; } if p > = paren . as_mut_ptr () . offset ( 100 as libc :: c_int as isize ) { return 0 as * mut libc :: c_char ; } ( * p ) . nalt = nalt ; ( * p ) . natom = natom ; p = p . offset ( 1 ) ; p ; nalt = 0 as libc :: c_int ; natom = 0 as libc :: c_int ; } 124 = > { if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh1 = dst ; dst = dst . offset ( 1 ) ; * fresh1 = . as i32 as libc :: c_char ; } nalt += 1 ; nalt ; } 41 = > { if p == paren . as_mut_ptr () { return 0 as * mut libc :: c_char ; } if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh2 = dst ; dst = dst . offset ( 1 ) ; * fresh2 = . as i32 as libc :: c_char ; } while nalt > 0 as libc :: c_int { let fresh3 = dst ; dst = dst . offset ( 1 ) ; * fresh3 = as i32 as libc :: c_char ; nalt -= 1 ; nalt ; } p = p . offset ( - 1 ) ; p ; nalt = ( * p ) . nalt ; natom = ( * p ) . natom ; natom += 1 ; natom ; } 42 43 63 = > { if natom == 0 as libc :: c_int { return 0 as * mut libc :: c_char ; } let fresh4 = dst ; dst = dst . offset ( 1 ) ; * fresh4 = * re ; } _ = > { if natom > 1 as libc :: c_int { natom -= 1 ; natom ; let fresh5 = dst ; dst = dst . offset ( 1 ) ; * fresh5 = . as i32 as libc :: c_char ; } let fresh6 = dst ; dst = dst . offset ( 1 ) ; * fresh6 = * re ; natom += 1 ; natom ; } } re = re . offset ( 1 ) ; re ; } if p ! = paren . as_mut_ptr () { return 0 as * mut libc :: c_char ; } loop { natom -= 1 ; if ! ( natom > 0 as libc :: c_int ) { break ; } let fresh7 = dst ; dst = dst . offset ( 1 ) ; * fresh7 = . as i32 as libc :: c_char ; } while nalt > 0 as libc :: c_int { let fresh8 = dst ; dst = dst . offset ( 1 ) ; * fresh8 = as i32 as libc :: c_char ; nalt -= 1 ; nalt ; } * dst = 0 as libc :: c_int as libc :: c_char ; return buf . as_mut_ptr () ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut matchstate : State = { let mut init = State { c : Match as libc :: c_int , out : 0 as *) (topLevelItem (constDef const State <missing ':'> (type (basicType (typePath as))) * mut State , out1 : 0 as *)) (topLevelItem (constDef const State <missing ':'> (type (basicType (typePath as))) * mut State , lastlist : 0 , } ; init } ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut nstate : libc :: c_int = 0 ;) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn state ( (paramList (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut out : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out1 : (type (pointerType * mut (type (basicType (typePath State)))))) , param) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (literal 0)) <missing ';'>)) as * mut State ; nstate += 1 ; nstate ; s = malloc ( :: core :: mem :: size_of :: < State > () as libc :: c_ulong ) as * mut State ; ( * s ) . lastlist = 0 as libc :: c_int ; ( * s ) . c = c ; ( * s ) . out = out ; ( * s ) . out1 = out1 ; return s ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn frag ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) ) -> (type (basicType (typePath Frag))) (block { (statement (letStmt let (varDef (mutableDef mut n : (type (basicType (typePath Frag))))) = (expression {) <missing ';'>)) (statement (letStmt let (varDef (mutableDef mut init)) = (expression (primaryExpression Frag)) {)) start : start , out : out } ; init } ; return n ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn list1 ( (paramList (param mut outp : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef (mutableDef mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (literal 0)) <missing ';'>)) as * mut Ptrlist ; l = outp as * mut Ptrlist ; ( * l ) . next = 0 as * mut Ptrlist ; return l ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn patch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (letStmt let (varDef (mutableDef mut next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (literal 0)) <missing ';'>)) as * mut Ptrlist ; while ! l . is_null () { next = ( * l ) . next ; ( * l ) . s = s ; l = next ; } }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn append ( (paramList (param mut l1_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut l2_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , param) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef (mutableDef mut oldl1 : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) = (expression (literal 0)) <missing ';'>)) as * mut Ptrlist ; oldl1 = l1_0 ; while ! ( ( * l1_0 ) . next ) . is_null () { l1_0 = ( * l1_0 ) . next ; } ( * l1_0 ) . next = l2_0 ; return oldl1 ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn post2nfa ( (paramList (param mut postfix : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef (mutableDef mut p : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (literal 0)) <missing ';'>)) as * mut libc :: c_char ; let mut stack : [ Frag ; 1000 ] = [ Frag { start : 0 as * mut State , out : 0 as * mut Ptrlist , } ; 1000 ] ; let mut stackp : * mut Frag = 0 as * mut Frag ; let mut e1 : Frag = Frag { start : 0 as * mut State , out : 0 as * mut Ptrlist , } ; let mut e2 : Frag = Frag { start : 0 as * mut State , out : 0 as * mut Ptrlist , } ; let mut e : Frag = Frag { start : 0 as * mut State , out : 0 as * mut Ptrlist , } ; let mut s : * mut State = 0 as * mut State ; if postfix . is_null () { return 0 as * mut State ; } stackp = stack . as_mut_ptr () ; p = postfix ; while * p ! = 0 { match * p as libc :: c_int { 46 = > { stackp = stackp . offset ( - 1 ) ; e2 = * stackp ; stackp = stackp . offset ( - 1 ) ; e1 = * stackp ; patch ( e1 . out , e2 . start ) ; let fresh10 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh10 = frag ( e1 . start , e2 . out ) ; } 124 = > { stackp = stackp . offset ( - 1 ) ; e2 = * stackp ; stackp = stackp . offset ( - 1 ) ; e1 = * stackp ; s = state ( Split as libc :: c_int , e1 . start , e2 . start ) ; let fresh11 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh11 = frag ( s , append ( e1 . out , e2 . out ) ) ; } 63 = > { stackp = stackp . offset ( - 1 ) ; e = * stackp ; s = state ( Split as libc :: c_int , e . start , 0 as * mut State ) ; let fresh12 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh12 = frag ( s , append ( e . out , list1 ( & mut ( * s ) . out1 ) ) ) ; } 42 = > { stackp = stackp . offset ( - 1 ) ; e = * stackp ; s = state ( Split as libc :: c_int , e . start , 0 as * mut State ) ; patch ( e . out , s ) ; let fresh13 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh13 = frag ( s , list1 ( & mut ( * s ) . out1 ) ) ; } 43 = > { stackp = stackp . offset ( - 1 ) ; e = * stackp ; s = state ( Split as libc :: c_int , e . start , 0 as * mut State ) ; patch ( e . out , s ) ; let fresh14 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh14 = frag ( e . start , list1 ( & mut ( * s ) . out1 ) ) ; } _ = > { s = state ( * p as libc :: c_int , 0 as * mut State , 0 as * mut State ) ; let fresh9 = stackp ; stackp = stackp . offset ( 1 ) ; * fresh9 = frag ( s , list1 ( & mut ( * s ) . out ) ) ; } } p = p . offset ( 1 ) ; p ; } stackp = stackp . offset ( - 1 ) ; e = * stackp ; if stackp ! = stack . as_mut_ptr () { return 0 as * mut State ; } patch ( e . out , & mut matchstate ) ; return e . start ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut l1 : List = List { s : 0 as *) (topLevelItem (constDef const * mut State as * mut * mut State , n : 0 , } ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) topLevelItem (topLevelItem pub static mut l2 : List = List { s : 0 as *) (topLevelItem (constDef const * mut State as * mut * mut State , n : 0 , } ; static mut listid : libc :: c_int = 0 ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn startlist ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) , param) ) -> (type (pointerType * mut (type (basicType (typePath List))))) (block { ( * l ) . n = 0 as libc :: c_int ; listid += 1 ; listid ; addstate ( l , start ) ; return l ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn ismatch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List))))))) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (assignStmt (expression (primaryExpression i)) = (expression (literal 0)) <missing ';'>)) as libc :: c_int ; while i < ( * l ) . n { if * ( ( * l ) . s ) . offset ( i as isize ) == & mut matchstate as * mut State { return 1 as libc :: c_int ; } i += 1 ; i ; } return 0 as libc :: c_int ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn addstate ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (ifStmt if (expression (expression (primaryExpression s)) . is_null) (block ()))) ( * s ) . lastlist == listid { return ; } ( * s ) . lastlist = listid ; if ( * s ) . c == Split as libc :: c_int { addstate ( l , ( * s ) . out ) ; addstate ( l , ( * s ) . out1 ) ; return ; } let fresh15 = ( * l ) . n ; ( * l ) . n = ( * l ) . n + 1 ; let ref mut fresh16 = * ( ( * l ) . s ) . offset ( fresh15 as isize ) ; * fresh16 = s ; }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn step ( (paramList (param mut clist : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut nlist : (type (pointerType * mut (type (basicType (typePath List)))))) , param) ) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut s : (type (pointerType * mut (type (basicType (typePath State))))))) = (expression (literal 0)) <missing ';'>)) as * mut State ; listid += 1 ; listid ; ( * nlist ) . n = 0 as libc :: c_int ; i = 0 as libc :: c_int ; while i < ( * clist ) . n { s = * ( ( * clist ) . s ) . offset ( i as isize ) ; if ( * s ) . c == c { addstate ( nlist , ( * s ) . out ) ; } i += 1 ; i ; } }))) (topLevelItem (attributes (innerAttribute # [ (attribute export_name) = "match" ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn match_0 ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) , param) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut c : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut clist : (type (pointerType * mut (type (basicType (typePath List))))))) = (expression (literal 0)) <missing ';'>)) as * mut List ; let mut nlist : * mut List = 0 as * mut List ; let mut t : * mut List = 0 as * mut List ; clist = startlist ( start , & mut l1 ) ; nlist = & mut l2 ; while * s ! = 0 { c = * s as libc :: c_int & 0 xff as libc :: c_int ; step ( clist , c , nlist ) ; t = clist ; clist = nlist ; nlist = t ; s = s . offset ( 1 ) ; s ; } return ismatch ( clist ) ; }))) (topLevelItem (functionDef (unsafeModifier unsafe) fn main_0 ( (paramList (param mut argc : (type (basicType (typePath libc :: c_int)))) , (param mut argv : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))))) , param) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef (mutableDef mut i : (type (basicType (typePath libc :: c_int))))) = (expression (literal 0)) ;)) (statement (letStmt let (varDef (mutableDef mut post : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) = (expression (literal 0)) <missing ';'>)) as * mut libc :: c_char ; let mut start : * mut State = 0 as * mut State ; if argc < 3 as libc :: c_int { fprintf ( stderr , b "usage: nfa regexp string...\n\0" as *))) (topLevelItem (constDef const u8 <missing ':'> (type (basicType (typePath as))) *)) (topLevelItem (constDef const libc :: c_char , ) ; return 1 as libc :: c_int ; } post = re2post ( * argv . offset ( 1 as libc :: c_int as isize ) ) ; if post . is_null () { fprintf ( stderr , b "bad regexp %s\n\0" as *)) (topLevelItem (constDef const u8 <missing ':'> (type (basicType (typePath as))) *)) (topLevelItem (constDef const libc :: c_char , * argv . offset ( 1 as libc :: c_int as isize ) , ) ; return 1 as libc :: c_int ; } start = post2nfa ( post ) ; if start . is_null () { fprintf ( stderr , b "error in post2nfa %s\n\0" as *)) (topLevelItem (constDef const u8 <missing ':'> (type (basicType (typePath as))) *)) (topLevelItem (constDef const libc :: c_char , post , ) ; return 1 as libc :: c_int ; } l1 . s = malloc ( ( nstate as libc :: c_ulong ) . wrapping_mul ( :: core :: mem :: size_of :: < * mut State > () as libc :: c_ulong ) , ) as * mut * mut State ; l2 . s = malloc ( ( nstate as libc :: c_ulong ) . wrapping_mul ( :: core :: mem :: size_of :: < * mut State > () as libc :: c_ulong ) , ) as * mut * mut State ; i = 2 as libc :: c_int ; while i < argc { if match_0 ( start , * argv . offset ( i as isize ) ) ! = 0 { printf ( b "%s\n\0" as *)) (topLevelItem (constDef const u8 <missing ':'> (type (basicType (typePath as))) *)) (topLevelItem (constDef const libc :: c_char , * argv . offset ( i as isize ) , ) ; } i += 1 ; i ; } return 0 as libc :: c_int ; })) (topLevelItem (functionDef (visibility pub) fn main () { let mut args : Vec :: < * mut libc :: c_char > = Vec :: new () ; for arg in :: std :: env :: args () { args . push ( ( :: std :: ffi :: CString :: new ( arg ) ) . expect ( "Failed to convert argument into CString." ) . into_raw () , ) ; } args . push ( :: core :: ptr :: null_mut () ) ;)) topLevelItem (topLevelItem unsafe { :: std :: process :: exit ( main_0 ( ( args . len () - 1 ) as libc :: c_int , args . as_mut_ptr () as * mut * mut libc :: c_char , ) as i32 , ) } }))