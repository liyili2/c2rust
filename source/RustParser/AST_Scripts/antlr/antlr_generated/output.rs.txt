Here's the parsing result:
(program (topLevelItem (attributes (innerAttribute # ! [ (attribute allow ( (attrArgs (attrArg dead_code) , (attrArg mutable_transmutes) , (attrArg non_camel_case_types) , (attrArg non_snake_case) , (attrArg non_upper_case_globals) , (attrArg unused_assignments) , (attrArg unused_mut)) )) ]) (innerAttribute # ! [ (attribute feature ( (attrArgs (attrArg extern_types)) )) ]))) (topLevelItem (externBlock extern "C" { (externItem (visibility pub) type _IO_wide_data ;) (externItem (visibility pub) type _IO_codecvt ;) (externItem (visibility pub) type _IO_marker ;) (externItem static mut stderr : (type (pointerType * mut (type (basicType (typePath FILE))))) ;) (externItem fn fprintf ( (externParams (externParam _ : (type (pointerType * mut (type (basicType (typePath FILE)))))) , (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn printf ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (externParam _ : ...)) ) -> (type (basicType (typePath libc :: c_int))) ;) (externItem fn malloc ( (externParams (externParam _ : (type (basicType (typePath libc :: c_ulong))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ;) (externItem fn strlen ( (externParams (externParam _ : (type (pointerType * const (type (basicType (typePath libc :: c_char))))))) ) -> (type (basicType (typePath libc :: c_ulong))) ;) })) (topLevelItem (typeAlias (visibility pub) type size_t = (type (basicType (typePath libc :: c_ulong))) ;)) (topLevelItem (typeAlias (visibility pub) type __off_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (typeAlias (visibility pub) type __off64_t = (type (basicType (typePath libc :: c_long))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct _IO_FILE { (structField (visibility pub) _flags : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _IO_read_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_read_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_ptr : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_write_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_buf_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_backup_base : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _IO_save_end : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) ,) (structField (visibility pub) _markers : (type (pointerType * mut (type (basicType (typePath _IO_marker))))) ,) (structField (visibility pub) _chain : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _fileno : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _flags2 : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _old_offset : (type (basicType (typePath __off_t))) ,) (structField (visibility pub) _cur_column : (type (basicType (typePath libc :: c_ushort))) ,) (structField (visibility pub) _vtable_offset : (type (basicType (typePath libc :: c_schar))) ,) (structField (visibility pub) _shortbuf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 1 ])) ,) (structField (visibility pub) _lock : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) _offset : (type (basicType (typePath __off64_t))) ,) (structField (visibility pub) _codecvt : (type (pointerType * mut (type (basicType (typePath _IO_codecvt))))) ,) (structField (visibility pub) _wide_data : (type (pointerType * mut (type (basicType (typePath _IO_wide_data))))) ,) (structField (visibility pub) _freeres_list : (type (pointerType * mut (type (basicType (typePath _IO_FILE))))) ,) (structField (visibility pub) _freeres_buf : (type (pointerType * mut (type (basicType (typePath libc :: c_void))))) ,) (structField (visibility pub) __pad5 : (type (basicType (typePath size_t))) ,) (structField (visibility pub) _mode : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) _unused2 : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 20 ])) ,) })) (topLevelItem (typeAlias (visibility pub) type _IO_lock_t = (type (basicType ())) ;)) (topLevelItem (typeAlias (visibility pub) type FILE = (type (basicType (typePath _IO_FILE))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct C2RustUnnamed { (structField (visibility pub) nalt : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) natom : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (typeAlias (visibility pub) type C2RustUnnamed_0 = (type (basicType (typePath libc :: c_uint))) ;)) (topLevelItem (constDef (visibility pub) const Split : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 257)))) ;)) (topLevelItem (constDef (visibility pub) const Match : (type (basicType (typePath C2RustUnnamed_0))) = (expression (postfixExpression (primaryExpression (literal 256)))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct State { (structField (visibility pub) c : (type (basicType (typePath libc :: c_int))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out1 : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) lastlist : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct Frag { (structField (visibility pub) start : (type (pointerType * mut (type (basicType (typePath State))))) ,) (structField (visibility pub) out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (unionDef (visibility pub) union Ptrlist { (unionField (visibility pub) next : (type (pointerType * mut (type (basicType (typePath Ptrlist))))) ,) (unionField (visibility pub) s : (type (pointerType * mut (type (basicType (typePath State))))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute derive ( (attrArgs (attrArg Copy) , (attrArg Clone)) )) ]) (innerAttribute # [ (attribute repr ( (attrArgs (attrArg C)) )) ]))) (topLevelItem (structDef (visibility pub) struct List { (structField (visibility pub) s : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))) ,) (structField (visibility pub) n : (type (basicType (typePath libc :: c_int))) ,) })) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn re2post ( (paramList (param mut re : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) (block { (statement (letStmt let (varDef mut nalt : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef mut natom : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (staticVarDecl static mut buf : (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) = (initializer (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression (literal 0)))) ; (expression (postfixExpression (primaryExpression (literal 8000)))) ])))))) ;)) (statement (letStmt let (varDef mut dst : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef mut paren : (type (basicType [ (type (basicType (typePath C2RustUnnamed))) ; 100 ]))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression C2RustUnnamed { (structLiteralField nalt : (expression (postfixExpression (primaryExpression (literal 0))))) , (structLiteralField natom : (expression (postfixExpression (primaryExpression (literal 0))))) }))) ; (expression (postfixExpression (primaryExpression (literal 100)))) ]))))) ;)) (statement (letStmt let (varDef mut p : (type (pointerType * mut (type (basicType (typePath C2RustUnnamed)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath C2RustUnnamed)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression strlen) ( (argumentList (expression (postfixExpression (primaryExpression re)))) ))) >= (expression (postfixExpression (primaryExpression ( (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType [ (type (basicType (typePath libc :: c_char))) ; 8000 ])) >()) as (type (basicType (typePath libc :: c_ulong)))) )) . wrapping_div ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 2)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath libc :: c_ulong))))) )))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (whileStmt while (expression (expression * (expression (postfixExpression (primaryExpression re)))) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement match (expression (expression * (expression (postfixExpression (primaryExpression re)))) as (type (basicType (typePath libc :: c_int)))) { (matchArm (matchPattern 40) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 1))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) (statement (letStmt let (varDef fresh0) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh0)))) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) >= (expression (postfixExpression (primaryExpression paren) . as_mut_ptr () . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 100)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath isize))))) )))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression p)))) )) . nalt)) = (expression (postfixExpression (primaryExpression nalt))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression p)))) )) . natom)) = (expression (postfixExpression (primaryExpression natom))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement p ;) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) })) (matchArm (matchPattern 124) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef fresh1) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh1)))) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (expression (postfixExpression (primaryExpression nalt))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) })) (matchArm (matchPattern 41) => (block { (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) == (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ()))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef fresh2) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh2)))) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (whileStmt while (expression (expression (expression (postfixExpression (primaryExpression nalt))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (letStmt let (varDef fresh3) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh3)))) = (expression (expression (postfixExpression (primaryExpression (literal '|')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (expression (postfixExpression (primaryExpression nalt))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement p ;) (statement (assignStmt (expression (postfixExpression (primaryExpression nalt))) = (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression p)))) )) . nalt)) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression natom))) = (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression p)))) )) . natom)) ;)) (statement (expression (postfixExpression (primaryExpression natom))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) })) (matchArm (matchPattern 42) | (matchPattern 43) | (matchPattern 63) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) == (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (letStmt let (varDef fresh4) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh4)))) = (expression * (expression (postfixExpression (primaryExpression re)))) ;)) })) (matchArm (matchPattern _) => (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 1))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) (statement (letStmt let (varDef fresh5) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh5)))) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (letStmt let (varDef fresh6) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh6)))) = (expression * (expression (postfixExpression (primaryExpression re)))) ;)) (statement (expression (postfixExpression (primaryExpression natom))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement natom ;) })) }) (statement (assignStmt (expression (postfixExpression (primaryExpression re))) = (expression (postfixExpression (primaryExpression re) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement re ;) }))) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression p))) != (expression (postfixExpression (primaryExpression paren) . as_mut_ptr ()))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) }))) (statement (loopStmt loop (block { (statement (expression (postfixExpression (primaryExpression natom))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement (ifStmt if (expression ! (expression (postfixExpression (primaryExpression ( (expression (expression (expression (postfixExpression (primaryExpression natom))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) ))))) (block { (statement break ;) }))) (statement (letStmt let (varDef fresh7) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh7)))) = (expression (expression (postfixExpression (primaryExpression (literal '.')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) }))) (statement (whileStmt while (expression (expression (expression (postfixExpression (primaryExpression nalt))) > (expression (postfixExpression (primaryExpression (literal 0))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (letStmt let (varDef fresh8) = (expression (postfixExpression (primaryExpression dst))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression dst))) = (expression (postfixExpression (primaryExpression dst) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh8)))) = (expression (expression (postfixExpression (primaryExpression (literal '|')))) as (type (basicType i32)) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (expression (postfixExpression (primaryExpression nalt))) -= (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nalt ;) }))) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression dst)))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath libc :: c_char)))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression buf) . as_mut_ptr ())) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut matchstate : (type (basicType (typePath State))) = (initializer (expression (expressionBlock { (statement (letStmt let (varDef mut init) = (expression (postfixExpression (primaryExpression State { (structLiteralField c : (expression (expression (postfixExpression (primaryExpression Match))) as (type (basicType (typePath libc :: c_int))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (basicType (typePath State))))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out1 : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (basicType (typePath State))))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField lastlist : (expression (postfixExpression (primaryExpression (literal 0))))) , }))) ;)) (expression (postfixExpression (primaryExpression init))) }))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut nstate : (type (basicType (typePath libc :: c_int))) = (initializer (expression (postfixExpression (primaryExpression (literal 0))))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn state ( (paramList (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut out : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out1 : (type (pointerType * mut (type (basicType (typePath State)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef mut s : (type (pointerType * mut (type (basicType (typePath State)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (expression (postfixExpression (primaryExpression nstate))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement nstate ;) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (expression (postfixExpression (primaryExpression malloc) ( (argumentList (expression (expression (typePath :: core :: mem :: size_of) :: < (type (basicType (typePath State))) >()) as (type (basicType (typePath libc :: c_ulong))))) ))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . lastlist)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . c)) = (expression (postfixExpression (primaryExpression c))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out)) = (expression (postfixExpression (primaryExpression out))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out1)) = (expression (postfixExpression (primaryExpression out1))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression s))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn frag ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut out : (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) ) -> (type (basicType (typePath Frag))) (block { (statement (letStmt let (varDef mut n : (type (basicType (typePath Frag)))) = (expression (expressionBlock { (statement (letStmt let (varDef mut init) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (postfixExpression (primaryExpression start)))) , (structLiteralField out : (expression (postfixExpression (primaryExpression out)))) }))) ;)) (expression (postfixExpression (primaryExpression init))) })) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression n))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn list1 ( (paramList (param mut outp : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression l))) = (expression (expression (postfixExpression (primaryExpression outp))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . next)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression l))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn patch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (letStmt let (varDef mut next : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (whileStmt while (expression ! (expression (postfixExpression (primaryExpression l) . is_null ()))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression next))) = (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . next)) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . s)) = (expression (postfixExpression (primaryExpression s))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression l))) = (expression (postfixExpression (primaryExpression next))) ;)) }))) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn append ( (paramList (param mut l1_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) , (param mut l2_0 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath Ptrlist))))) (block { (statement (letStmt let (varDef mut oldl1 : (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression oldl1))) = (expression (postfixExpression (primaryExpression l1_0))) ;)) (statement (whileStmt while (expression ! (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l1_0)))) )) . next)) )) . is_null ()))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression l1_0))) = (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l1_0)))) )) . next)) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l1_0)))) )) . next)) = (expression (postfixExpression (primaryExpression l2_0))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression oldl1))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn post2nfa ( (paramList (param mut postfix : (type (pointerType * mut (type (basicType (typePath libc :: c_char))))))) ) -> (type (pointerType * mut (type (basicType (typePath State))))) (block { (statement (letStmt let (varDef mut p : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef mut stack : (type (basicType [ (type (basicType (typePath Frag))) ; 1000 ]))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ; (expression (postfixExpression (primaryExpression (literal 1000)))) ]))))) ;)) (statement (letStmt let (varDef mut stackp : (type (pointerType * mut (type (basicType (typePath Frag)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Frag)))))) ;)) (statement (letStmt let (varDef mut e1 : (type (basicType (typePath Frag)))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef mut e2 : (type (basicType (typePath Frag)))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef mut e : (type (basicType (typePath Frag)))) = (expression (postfixExpression (primaryExpression Frag { (structLiteralField start : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) , (structLiteralField out : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath Ptrlist))))))) , }))) ;)) (statement (letStmt let (varDef mut s : (type (pointerType * mut (type (basicType (typePath State)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (ifStmt if (expression (postfixExpression (primaryExpression postfix) . is_null ())) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stack) . as_mut_ptr ())) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression postfix))) ;)) (statement (whileStmt while (expression (expression * (expression (postfixExpression (primaryExpression p)))) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement match (expression (expression * (expression (postfixExpression (primaryExpression p)))) as (type (basicType (typePath libc :: c_int)))) { (matchArm (matchPattern 46) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e2))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e1))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression patch) ( (argumentList (expression (postfixExpression (primaryExpression e1) . out)) , (expression (postfixExpression (primaryExpression e2) . start))) ))) ;)) (statement (letStmt let (varDef fresh10) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh10)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression e1) . start)) , (expression (postfixExpression (primaryExpression e2) . out))) ))) ;)) })) (matchArm (matchPattern 124) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e2))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e1))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state) ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e1) . start)) , (expression (postfixExpression (primaryExpression e2) . start))) ))) ;)) (statement (letStmt let (varDef fresh11) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh11)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression s))) , (qualifiedFunctionCall append ( (argumentList (expression (postfixExpression (primaryExpression e1) . out)) , (expression (postfixExpression (primaryExpression e2) . out))) ))) ))) ;)) })) (matchArm (matchPattern 63) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state) ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e) . start)) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) ))) ;)) (statement (letStmt let (varDef fresh12) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh12)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression s))) , (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) })) (matchArm (matchPattern 42) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state) ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e) . start)) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression patch) ( (argumentList (expression (postfixExpression (primaryExpression e) . out)) , (expression (postfixExpression (primaryExpression s)))) ))) ;)) (statement (letStmt let (varDef fresh13) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh13)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression s))) , (qualifiedFunctionCall list1 ( (argumentList (expression & mut (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out1)))) ))) ))) ;)) })) (matchArm (matchPattern 43) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state) ( (argumentList (expression (expression (postfixExpression (primaryExpression Split))) as (type (basicType (typePath libc :: c_int)))) , (expression (postfixExpression (primaryExpression e) . start)) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression patch) ( (argumentList (expression (postfixExpression (primaryExpression e) . out)) , (expression (postfixExpression (primaryExpression s)))) ))) ;)) (statement (letStmt let (varDef fresh14) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh14)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression e) . start)) , (qualifiedFunctionCall list1 ( (argumentList (expression & mut (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out1)))) ))) ))) ;)) })) (matchArm (matchPattern _) => (block { (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression state) ( (argumentList (expression (expression * (expression (postfixExpression (primaryExpression p)))) as (type (basicType (typePath libc :: c_int)))) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) , (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State))))))) ))) ;)) (statement (letStmt let (varDef fresh9) = (expression (postfixExpression (primaryExpression stackp))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh9)))) = (expression (postfixExpression (primaryExpression frag) ( (argumentList (expression (postfixExpression (primaryExpression s))) , (qualifiedFunctionCall list1 ( (argumentList (expression & mut (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out)))) ))) ))) ;)) })) }) (statement (assignStmt (expression (postfixExpression (primaryExpression p))) = (expression (postfixExpression (primaryExpression p) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement p ;) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression stackp))) = (expression (postfixExpression (primaryExpression stackp) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal -1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression e))) = (expression * (expression (postfixExpression (primaryExpression stackp)))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression stackp))) != (expression (postfixExpression (primaryExpression stack) . as_mut_ptr ()))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) }))) (statement (exprStmt (expression (postfixExpression (primaryExpression patch) ( (argumentList (expression (postfixExpression (primaryExpression e) . out)) , (expression & mut (expression (postfixExpression (primaryExpression matchstate))))) ))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression e) . start)) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut l1 : (type (basicType (typePath List))) = (initializer (expression (postfixExpression (primaryExpression List { (structLiteralField s : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (pointerType * mut (type (basicType (typePath State))))))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) , (structLiteralField n : (expression (postfixExpression (primaryExpression (literal 0))))) , })))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (staticVarDecl (visibility pub) static mut l2 : (type (basicType (typePath List))) = (initializer (expression (postfixExpression (primaryExpression List { (structLiteralField s : (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * const (type (pointerType * mut (type (basicType (typePath State))))))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State))))))))) , (structLiteralField n : (expression (postfixExpression (primaryExpression (literal 0))))) , })))) ;)) (topLevelItem (staticVarDecl static mut listid : (type (basicType (typePath libc :: c_int))) = (initializer (expression (postfixExpression (primaryExpression (literal 0))))) ;)) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn startlist ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) ,) ) -> (type (pointerType * mut (type (basicType (typePath List))))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . n)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (expression (postfixExpression (primaryExpression listid))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement listid ;) (statement (exprStmt (expression (postfixExpression (primaryExpression addstate) ( (argumentList (expression (postfixExpression (primaryExpression l))) , (expression (postfixExpression (primaryExpression start)))) ))) ;)) (statement (returnStmt return (expression (postfixExpression (primaryExpression l))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn ismatch ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List))))))) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef mut i : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression i))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (whileStmt while (expression (expression (postfixExpression (primaryExpression i))) < (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . n))) (block { (statement (ifStmt if (expression (expression * (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . s)) )) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression i))) as (type (basicType (typePath isize))))) )))) == (expression & mut (expression (expression (postfixExpression (primaryExpression matchstate))) as (type (pointerType * mut (type (basicType (typePath State)))))))) (block { (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (statement (expression (postfixExpression (primaryExpression i))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement i ;) }))) (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn addstate ( (paramList (param mut l : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath State))))))) ) (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression s) . is_null ())) || (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . lastlist))) == (expression (postfixExpression (primaryExpression listid)))) (block { (statement (returnStmt return ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . lastlist)) = (expression (postfixExpression (primaryExpression listid))) ;)) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . c)) == (expression (postfixExpression (primaryExpression Split)))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression addstate) ( (argumentList (expression (postfixExpression (primaryExpression l))) , (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression addstate) ( (argumentList (expression (postfixExpression (primaryExpression l))) , (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out1))) ))) ;)) (statement (returnStmt return ;)) }))) (statement (letStmt let (varDef fresh15) = (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . n)) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . n)) = (expression (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . n)) + (expression (postfixExpression (primaryExpression (literal 1))))) ;)) (statement (letStmt let (varDef ref mut fresh16) = (expression * (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression l)))) )) . s)) )) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression fresh15))) as (type (basicType (typePath isize))))) )))) ;)) (statement (assignStmt (expression * (expression (postfixExpression (primaryExpression fresh16)))) = (expression (postfixExpression (primaryExpression s))) ;)) }))) (topLevelItem (attributes (innerAttribute # [ (attribute no_mangle) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn step ( (paramList (param mut clist : (type (pointerType * mut (type (basicType (typePath List)))))) , (param mut c : (type (basicType (typePath libc :: c_int)))) , (param mut nlist : (type (pointerType * mut (type (basicType (typePath List)))))) ,) ) (block { (statement (letStmt let (varDef mut i : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef mut s : (type (pointerType * mut (type (basicType (typePath State)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (expression (postfixExpression (primaryExpression listid))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement listid ;) (statement (assignStmt (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression nlist)))) )) . n)) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression i))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (whileStmt while (expression (expression (postfixExpression (primaryExpression i))) < (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression clist)))) )) . n))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression * (expression (postfixExpression (primaryExpression ( (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression clist)))) )) . s)) )) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression i))) as (type (basicType (typePath isize))))) )))) ;)) (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . c)) == (expression (postfixExpression (primaryExpression c)))) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression addstate) ( (argumentList (expression (postfixExpression (primaryExpression nlist))) , (expression (postfixExpression (primaryExpression ( (expression * (expression (postfixExpression (primaryExpression s)))) )) . out))) ))) ;)) }))) (statement (expression (postfixExpression (primaryExpression i))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement i ;) }))) }))) (topLevelItem (attributes (innerAttribute # [ (attribute export_name = (attrValue "match")) ]))) (topLevelItem (functionDef (visibility pub) (unsafeModifier unsafe) (externAbi extern "C") fn match_0 ( (paramList (param mut start : (type (pointerType * mut (type (basicType (typePath State)))))) , (param mut s : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ,) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef mut i : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef mut c : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef mut clist : (type (pointerType * mut (type (basicType (typePath List)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (letStmt let (varDef mut nlist : (type (pointerType * mut (type (basicType (typePath List)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (letStmt let (varDef mut t : (type (pointerType * mut (type (basicType (typePath List)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath List)))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression clist))) = (expression (postfixExpression (primaryExpression startlist) ( (argumentList (expression (postfixExpression (primaryExpression start))) , (expression & mut (expression (postfixExpression (primaryExpression l1))))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression nlist))) = (expression & mut (expression (postfixExpression (primaryExpression l2)))) ;)) (statement (whileStmt while (expression (expression * (expression (postfixExpression (primaryExpression s)))) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement (assignStmt (expression (postfixExpression (primaryExpression c))) = (expression (expression (expression (expression * (expression (postfixExpression (primaryExpression s)))) as (type (basicType (typePath libc :: c_int)))) & (expression (postfixExpression (primaryExpression (literal 0xff))))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression step) ( (argumentList (expression (postfixExpression (primaryExpression clist))) , (expression (postfixExpression (primaryExpression c))) , (expression (postfixExpression (primaryExpression nlist)))) ))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression t))) = (expression (postfixExpression (primaryExpression clist))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression clist))) = (expression (postfixExpression (primaryExpression nlist))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression nlist))) = (expression (postfixExpression (primaryExpression t))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression s))) = (expression (postfixExpression (primaryExpression s) . offset ( (argumentList (expression (postfixExpression (primaryExpression (literal 1))))) ))) ;)) (statement s ;) }))) (statement (returnStmt return (expression (postfixExpression (primaryExpression ismatch) ( (argumentList (expression (postfixExpression (primaryExpression clist)))) ))) ;)) }))) (topLevelItem (functionDef (unsafeModifier unsafe) fn main_0 ( (paramList (param mut argc : (type (basicType (typePath libc :: c_int)))) , (param mut argv : (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))))) ,) ) -> (type (basicType (typePath libc :: c_int))) (block { (statement (letStmt let (varDef mut i : (type (basicType (typePath libc :: c_int)))) = (expression (postfixExpression (primaryExpression (literal 0)))) ;)) (statement (letStmt let (varDef mut post : (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))) ;)) (statement (letStmt let (varDef mut start : (type (pointerType * mut (type (basicType (typePath State)))))) = (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (pointerType * mut (type (basicType (typePath State)))))) ;)) (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression argc))) < (expression (postfixExpression (primaryExpression (literal 3))))) as (type (basicType (typePath libc :: c_int)))) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression fprintf) ( (argumentList (expression (postfixExpression (primaryExpression stderr))) , (expression (expression (postfixExpression (primaryExpression (literal b"usage: nfa regexp string...\n\0")))) as (type (pointerType * const (type (basicType u8)))) as (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) ,) ))) ;)) (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression post))) = (expression (postfixExpression (primaryExpression re2post) ( (argumentList (expression * (expression (postfixExpression (primaryExpression argv) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath isize))))) ))))) ))) ;)) (statement (ifStmt if (expression (postfixExpression (primaryExpression post) . is_null ())) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression fprintf) ( (argumentList (expression (postfixExpression (primaryExpression stderr))) , (expression (expression (postfixExpression (primaryExpression (literal b"bad regexp %s\n\0")))) as (type (pointerType * const (type (basicType u8)))) as (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (expression * (expression (postfixExpression (primaryExpression argv) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int))) as (type (basicType (typePath isize))))) )))) ,) ))) ;)) (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression start))) = (expression (postfixExpression (primaryExpression post2nfa) ( (argumentList (expression (postfixExpression (primaryExpression post)))) ))) ;)) (statement (ifStmt if (expression (postfixExpression (primaryExpression start) . is_null ())) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression fprintf) ( (argumentList (expression (postfixExpression (primaryExpression stderr))) , (expression (expression (postfixExpression (primaryExpression (literal b"error in post2nfa %s\n\0")))) as (type (pointerType * const (type (basicType u8)))) as (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (expression (postfixExpression (primaryExpression post))) ,) ))) ;)) (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 1)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (statement (assignStmt (expression (postfixExpression (primaryExpression l1) . s)) = (expression (expression (postfixExpression (primaryExpression malloc) ( (argumentList (expression (postfixExpression (primaryExpression ( (expression (expression (postfixExpression (primaryExpression nstate))) as (type (basicType (typePath libc :: c_ulong)))) )) . wrapping_mul ( (argumentList (expression (expression (typePath :: core :: mem :: size_of) :: < (type (pointerType * mut (type (basicType (typePath State))))) >()) as (type (basicType (typePath libc :: c_ulong))))) ))) ,) ))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State)))))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression l2) . s)) = (expression (expression (postfixExpression (primaryExpression malloc) ( (argumentList (expression (postfixExpression (primaryExpression ( (expression (expression (postfixExpression (primaryExpression nstate))) as (type (basicType (typePath libc :: c_ulong)))) )) . wrapping_mul ( (argumentList (expression (expression (typePath :: core :: mem :: size_of) :: < (type (pointerType * mut (type (basicType (typePath State))))) >()) as (type (basicType (typePath libc :: c_ulong))))) ))) ,) ))) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath State)))))))) ;)) (statement (assignStmt (expression (postfixExpression (primaryExpression i))) = (expression (expression (postfixExpression (primaryExpression (literal 2)))) as (type (basicType (typePath libc :: c_int)))) ;)) (statement (whileStmt while (expression (expression (postfixExpression (primaryExpression i))) < (expression (postfixExpression (primaryExpression argc)))) (block { (statement (ifStmt if (expression (expression (postfixExpression (primaryExpression match_0) ( (argumentList (expression (postfixExpression (primaryExpression start))) , (expression * (expression (postfixExpression (primaryExpression argv) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression i))) as (type (basicType (typePath isize))))) ))))) ))) != (expression (postfixExpression (primaryExpression (literal 0))))) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression printf) ( (argumentList (expression (expression (postfixExpression (primaryExpression (literal b"%s\n\0")))) as (type (pointerType * const)) as (type (pointerType * const (type (basicType (typePath libc :: c_char)))))) , (expression * (expression (postfixExpression (primaryExpression argv) . offset ( (argumentList (expression (expression (postfixExpression (primaryExpression i))) as (type (basicType (typePath isize))))) )))) ,) ))) ;)) }))) (statement (expression (postfixExpression (primaryExpression i))) += (expression (postfixExpression (primaryExpression (literal 1)))) ;) (statement i ;) }))) (statement (returnStmt return (expression (expression (postfixExpression (primaryExpression (literal 0)))) as (type (basicType (typePath libc :: c_int)))) ;)) }))) (topLevelItem (functionDef (visibility pub) fn main () (block { (statement (letStmt let (varDef mut args : (type (basicType (typePath Vec ::) < (type (pointerType * mut (type (basicType (typePath libc :: c_char))))) >))) = (expression (postfixExpression (primaryExpression (qualifiedFunctionCall Vec :: new ())))) ;)) (statement (forStmt for arg in (expression :: std :: env :: args ()) (block { (statement (exprStmt (expression (postfixExpression (primaryExpression args) . push ( (argumentList (expression (postfixExpression (primaryExpression ( (expression :: std :: ffi :: CString :: new ( (argumentList (expression (postfixExpression (primaryExpression arg)))) )) )) . expect ( (argumentList (expression (postfixExpression (primaryExpression (literal "Failed to convert argument into CString."))))) ) . into_raw ())) ,) ))) ;)) }))) (statement (exprStmt (expression (postfixExpression (primaryExpression args) . push ( (argumentList (expression :: core :: ptr :: null_mut ())) ))) ;)) (statement (unsafeBlock unsafe (block { (statement (exprStmt (expression :: std :: process :: exit ( (argumentList (expression (expression (postfixExpression (primaryExpression main_0) ( (argumentList (expression (expression (postfixExpression (primaryExpression ( (expression (expression (postfixExpression (primaryExpression args) . len ())) - (expression (postfixExpression (primaryExpression (literal 1))))) )))) as (type (basicType (typePath libc :: c_int)))) , (expression (expression (postfixExpression (primaryExpression args) . as_mut_ptr ())) as (type (pointerType * mut (type (pointerType * mut (type (basicType (typePath libc :: c_char)))))))) ,) ))) as (type (basicType i32))) ,) )) ;)) }))) }))))