Here's the parsing result:
(program (topLevelItem (functionDef fn aggregate ( (paramList (param list : (referenceType & (type (basicType [ (type (basicType i32)) ]))))) ) -> (type (basicType Vec < (type (basicType i32)) >)) (block { (statement (letStmt let (varDef (immutableDef len)) = (expression (expression (primaryExpression list)) . len ( )) ;)) (statement (letStmt let (varDef (mutableDef mut ret)) = (expression (macroCall vec ! (macroArgs [ (macroInner (expression (literal 0)) ; (expression (expression (primaryExpression ( (expression (expression (primaryExpression len)) >> (expression (literal 1))) ))) + (expression (primaryExpression ( (expression (expression (primaryExpression len)) & (expression (literal 0b0001))) ))))) ]))) ;)) (statement (forStmt for i in (expression (expression (literal 0)) .. (expression (primaryExpression len))) (block { (statement (ifStmt if (expression (expression (expression (primaryExpression i)) % (expression (literal 2))) == (expression (literal 1))) (block { (statement (exprStmt (expression (expression (expression (primaryExpression ret)) [ (expression (expression (primaryExpression i)) / (expression (literal 2))) ]) += (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ])) ;)) }) else (block { (statement (assignStmt (expression (expression (primaryExpression ret)) [ (expression (expression (primaryExpression i)) / (expression (literal 2))) ]) = (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ]) ;)) }))) }))) (returnStmt (expression (primaryExpression ret))) }))) (topLevelItem (functionDef fn printall ( (paramList (param list : (referenceType & (type (basicType [ (type (basicType i32)) ]))))) ) (block { (statement (exprStmt (expression (macroCall print ! (macroArgs ( (macroInner (expression (literal (stringLiteral " [ ")))) )))) ;)) (statement (forStmt for i in (expression (expression (literal 0)) .. (expression (expression (primaryExpression list)) . len ( ))) (block { (statement (exprStmt (expression print ! ( (argumentList (expression (literal (stringLiteral " { } , "))) , (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ])) )) ;)) }))) (statement (exprStmt (expression (macroCall println ! (macroArgs ( (macroInner (expression (literal (stringLiteral " ] ")))) )))) ;)) }))) (topLevelItem (functionDef fn main ( ) (block { (statement (letStmt let (varDef (immutableDef test1 : (type (basicType [ (type (basicType i32)) ; 6 ])))) = (expression (literal (arrayLiteral [ (expression (literal 1)) , (expression (literal 2)) , (expression (literal 3)) , (expression (literal 4)) , (expression (literal 5)) , (expression (literal 6)) ]))) ;)) (statement (letStmt let (varDef (immutableDef ret1)) = (expression (primaryExpression aggregate ( (argumentList (expression (borrowExpression & (expression (primaryExpression test1))))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression (borrowExpression & (expression (primaryExpression test1))))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression (borrowExpression & (expression (primaryExpression ret1))))) ))) ;)) (statement (letStmt let (varDef (immutableDef test2 : (type (basicType [ (type (basicType i32)) ; 5 ])))) = (expression (literal (arrayLiteral [ (expression (literal 1)) , (expression (literal 2)) , (expression (literal 3)) , (expression (literal 4)) , (expression (literal 5)) ]))) ;)) (statement (letStmt let (varDef (immutableDef ret2)) = (expression (primaryExpression aggregate ( (argumentList (expression (borrowExpression & (expression (primaryExpression test2))))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression (borrowExpression & (expression (primaryExpression test2))))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression (borrowExpression & (expression (primaryExpression ret2))))) ))) ;)) }))))