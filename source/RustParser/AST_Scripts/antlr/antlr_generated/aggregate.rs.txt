Here's the parsing result:
(program (topLevelItem (functionDef fn aggregate ( (paramList (param list : (type (basicType & (type (basicType [ (type (basicType i32)) ])))))) ) -> (type (basicType (typePath Vec) < (type (basicType i32)) >)) (block { (statement (letStmt let (varDef len) = (expression (postfixExpression (primaryExpression list) . len ())) ;)) (statement (letStmt let (varDef mut ret) = (expression (macroCall vec ! (macroArgs [ (macroInner (expression (postfixExpression (primaryExpression (literal 0)))) ; (expression (expression (postfixExpression (primaryExpression ( (expression (expression (postfixExpression (primaryExpression len))) >> (expression (postfixExpression (primaryExpression (literal 1))))) )))) + (expression (postfixExpression (primaryExpression ( (expression (expression (postfixExpression (primaryExpression len))) & (expression (postfixExpression (primaryExpression (literal 0b0001))))) )))))) ]))) ;)) (statement (forStmt for i in (expression (expression (postfixExpression (primaryExpression (literal 0)))) .. (expression (postfixExpression (primaryExpression len)))) (block { (statement (ifStmt if (expression (expression (expression (postfixExpression (primaryExpression i))) % (expression (postfixExpression (primaryExpression (literal 2))))) == (expression (postfixExpression (primaryExpression (literal 1))))) (block { (statement (expression (postfixExpression (primaryExpression ret) [ (expression (expression (postfixExpression (primaryExpression i))) / (expression (postfixExpression (primaryExpression (literal 2))))) ])) += (expression (postfixExpression (primaryExpression list) [ (expression (postfixExpression (primaryExpression i))) ])) ;) }) else (block { (statement (assignStmt (expression (postfixExpression (primaryExpression ret) [ (expression (expression (postfixExpression (primaryExpression i))) / (expression (postfixExpression (primaryExpression (literal 2))))) ])) = (expression (postfixExpression (primaryExpression list) [ (expression (postfixExpression (primaryExpression i))) ])) ;)) }))) }))) (statement (returnStmt ret)) }))) (topLevelItem (functionDef fn printall ( (paramList (param list : (type (basicType & (type (basicType [ (type (basicType i32)) ])))))) ) (block { (statement (exprStmt (expression (macroCall print ! (macroArgs ( (macroInner (expression (postfixExpression (primaryExpression (literal "["))))) )))) ;)) (statement (forStmt for i in (expression (expression (postfixExpression (primaryExpression (literal 0)))) .. (expression (postfixExpression (primaryExpression list) . len ()))) (block { (statement (exprStmt (expression print ! ( (argumentList (expression (postfixExpression (primaryExpression (literal "{}, ")))) , (expression (postfixExpression (primaryExpression list) [ (expression (postfixExpression (primaryExpression i))) ]))) )) ;)) }))) (statement (exprStmt (expression (macroCall println ! (macroArgs ( (macroInner (expression (postfixExpression (primaryExpression (literal "]"))))) )))) ;)) }))) (topLevelItem (functionDef fn main () (block { (statement (letStmt let (varDef test1 : (type (basicType [ (type (basicType i32)) ; 6 ]))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression (literal 1)))) , (expression (postfixExpression (primaryExpression (literal 2)))) , (expression (postfixExpression (primaryExpression (literal 3)))) , (expression (postfixExpression (primaryExpression (literal 4)))) , (expression (postfixExpression (primaryExpression (literal 5)))) , (expression (postfixExpression (primaryExpression (literal 6)))) ]))))) ;)) (statement (letStmt let (varDef ret1) = (expression (postfixExpression (primaryExpression aggregate) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression test1)))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression printall) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression test1)))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression printall) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression ret1)))))) ))) ;)) (statement (letStmt let (varDef test2 : (type (basicType [ (type (basicType i32)) ; 5 ]))) = (expression (postfixExpression (primaryExpression (literal (arrayLiteral [ (expression (postfixExpression (primaryExpression (literal 1)))) , (expression (postfixExpression (primaryExpression (literal 2)))) , (expression (postfixExpression (primaryExpression (literal 3)))) , (expression (postfixExpression (primaryExpression (literal 4)))) , (expression (postfixExpression (primaryExpression (literal 5)))) ]))))) ;)) (statement (letStmt let (varDef ret2) = (expression (postfixExpression (primaryExpression aggregate) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression test2)))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression printall) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression test2)))))) ))) ;)) (statement (exprStmt (expression (postfixExpression (primaryExpression printall) ( (argumentList (expression (borrowExpression & (expression (postfixExpression (primaryExpression ret2)))))) ))) ;)) }))))