Here's the parsing result:
(program (functionDef fn aggregate ( (paramList (param list : (referenceType & (type [ (type i32) ])))) ) -> (type Vec < (type i32) >) (block { (statement (letStmt let len = (expression (expression (primaryExpression list)) . len ( )) ;)) (statement (letStmt let mut ret = (expression (macroCall vec ! (macroArgs [ (macroInner (expression (primaryExpression (literal 0))) ; (expression (expression (primaryExpression ( (expression (expression (primaryExpression len)) >> (expression (primaryExpression (literal 1)))) ))) + (expression (primaryExpression ( (expression (expression (primaryExpression len)) & (expression (primaryExpression (literal 0b0001)))) ))))) ]))) ;)) (statement (forStmt for i in (expression (expression (primaryExpression (literal 0))) .. (expression (primaryExpression len))) (block { (statement (ifStmt if (expression (expression (expression (primaryExpression i)) % (expression (primaryExpression (literal 2)))) == (expression (primaryExpression (literal 1)))) (block { (statement (exprStmt (expression (expression (expression (primaryExpression ret)) [ (expression (expression (primaryExpression i)) / (expression (primaryExpression (literal 2)))) ]) += (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ])) ;)) }) else (block { (statement (assignStmt (expression (expression (primaryExpression ret)) [ (expression (expression (primaryExpression i)) / (expression (primaryExpression (literal 2)))) ]) = (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ]) ;)) }))) }))) (returnStmt (expression (primaryExpression ret))) })) (functionDef fn printall ( (paramList (param list : (referenceType & (type [ (type i32) ])))) ) (block { (statement (exprStmt (expression (macroCall print ! (macroArgs ( (macroInner (expression (primaryExpression (literal (stringLiteral " [ "))))) )))) ;)) (statement (forStmt for i in (expression (expression (primaryExpression (literal 0))) .. (expression (expression (primaryExpression list)) . len ( ))) (block { (statement (exprStmt (expression print ! ( (argumentList (expression (primaryExpression (literal (stringLiteral " { } , ")))) , (expression (expression (primaryExpression list)) [ (expression (primaryExpression i)) ])) )) ;)) }))) (statement (exprStmt (expression (macroCall println ! (macroArgs ( (macroInner (expression (primaryExpression (literal (stringLiteral " ] "))))) )))) ;)) })) (functionDef fn main ( ) (block { (statement (letStmt let test1 : (type [ (type i32) ; 6 ]) = (expression (primaryExpression (literal (arrayLiteral [ (expression (primaryExpression (literal 1))) , (expression (primaryExpression (literal 2))) , (expression (primaryExpression (literal 3))) , (expression (primaryExpression (literal 4))) , (expression (primaryExpression (literal 5))) , (expression (primaryExpression (literal 6))) ])))) ;)) (statement (letStmt let ret1 = (expression (primaryExpression aggregate ( (argumentList (expression & (expression (primaryExpression test1)))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression & (expression (primaryExpression test1)))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression & (expression (primaryExpression ret1)))) ))) ;)) (statement (letStmt let test2 : (type [ (type i32) ; 5 ]) = (expression (primaryExpression (literal (arrayLiteral [ (expression (primaryExpression (literal 1))) , (expression (primaryExpression (literal 2))) , (expression (primaryExpression (literal 3))) , (expression (primaryExpression (literal 4))) , (expression (primaryExpression (literal 5))) ])))) ;)) (statement (letStmt let ret2 = (expression (primaryExpression aggregate ( (argumentList (expression & (expression (primaryExpression test2)))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression & (expression (primaryExpression test2)))) ))) ;)) (statement (exprStmt (expression (primaryExpression printall ( (argumentList (expression & (expression (primaryExpression ret2)))) ))) ;)) })))